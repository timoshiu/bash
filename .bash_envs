# -*- mode: sh; -*-

alias env='env_manager $@' # note: use "\env" to call bash's env

function env_manager() {
    # see env_help() for doc

    local file_envs=`env_get_input $@`
    local file_export=`env_get_output ${file_envs}`
    local file_query="${file_envs}.query"
    local file_print="${file_envs}.print"
    local file_value="${file_envs}.value"

    local flag_edit_lhs=`env_get_flag -e $@`
    local flag_edit_rhs=`env_get_flag -v $@`
    local flag_edit="0"
    if [ $flag_edit_lhs == "1" -o $flag_edit_rhs == "1" ] ; then
	flag_edit="1"
    fi
    if [ $flag_edit == "0" -a -e ${file_print} ] ; then
	env_print ${file_print}	
	return
    fi

    env_edit_file ${file_envs} ${flag_edit_lhs}
    env_make_query ${file_envs} ${file_query}
    env_make_value ${file_query} ${file_value}
    env_make_print ${file_query} ${file_print}
    
    env_edit_file ${file_value} ${flag_edit}
    env_make_export ${file_value} ${file_export}
    env_export ${file_export}
    env_print ${file_print}
}

function env_get_flag() {
    # env_manager() helper
    local flag="$1"
    shift
    local args="$*"
    for arg in ${args} ; do
	case ${arg} in
	    $flag) 
		printf "1\n"
		return
		;;
	    *) 
		# echo ${arg}
		;;
	esac
    done

    printf "0\n"
}

function env_get_file() {
    # env_manager() helper
    local args="$*"
    for arg in ${args} ; do
	case ${arg} in
	    -*) 
		# echo ${arg}
		;;
	    *) 
		printf "$arg\n"
		return
		;;
	esac
    done
    printf ".env\n"
}

function env_get_input() {
    # env_manager() helper (.env default)

    local file_envs=`env_get_file $@`
    
    if [ ! -e ${file_envs} -a -e ~/${file_envs} ] ; then
	cp -f ~/${file_envs} ${file_envs}
    fi

    if [ ! -e ${file_envs} ] ; then
	echo "cannot find file" ${file_envs}
	return
    fi

    printf "${file_envs}\n"
}

function env_get_output() {
    # env_manager() helper (.env.export default)
    local file_envs=""
    local file_export=""

    if [ $# -ge 1 ] ; then
	file_envs=$1
	file_export="${file_envs}.export"
    fi

    printf "${file_export}\n"
}

function env_make_query() {
    # env_manager() helper (.env.query default)
    local file_envs=$1
    local file_query=$2

    if [ ! -e ${file_envs} ] ; then
	return
    fi

    sed -e "s/^ *\([A-Z_][A-Z_a-z0-9]*\) *$/\1=$\{`eval "echo '\1'"`\}/" \
	${file_envs} \
	> ${file_query}
}

function env_make_value() {
    # env_manager() helper (.env.value default)
    local file_query=$1
    local file_value=$2

    if [ ! -e ${file_query} ] ; then
	return
    fi

    eval "echo \"`cat ${file_query}`\"" \
	| sed -e "s/ /\\ /g" \
	| awk -F"[=:]" '{if(0==NF){print $0} if(2==NF){print $0} if(3<=NF){print $1"="$2} for(i=3;i<NF;i++){print $1"+="$i}}' \
	> ${file_value}
}

function env_make_print() {
    # env_manager() helper (.env.print default)
    local file_query=$1
    local file_print=$2

    if [ ! -e ${file_query} ] ; then
	return
    fi

    cat -n ${file_query} \
	| sed -e 's/^[[:space:]]*\([0-9]*\)[[:space:]]*\([^\ =]*\)=\(.*\)$/printf "%2d \2=\3\\n" \1/g' \
	| sed -e 's/^[[:space:]]*\([0-9]*\)[[:space:]]*$/printf "%2d \\n" \1/g' \
	> ${file_print}
}

function env_print() {
    # env_manager() helper
    local file_print=$1

    if [ ! -e ${file_print} ] ; then
	echo "error: file not found, " ${file_print}
	return
    fi

    local RED=`echo -e '\033[31m'`
    local YELLOW=`echo -e '\033[33m'`
    local MAGENTA=`echo -e '\033[35m'`
    local GREEN=`echo -e '\033[32m'`
    local NORMAL=`echo -e '\033[0m'`

    eval "`cat ${file_print}`" \
	| sed "s/\(#.*\)/$RED\1$NORMAL/g" \
	| sed "s/\([^ ]*\)=\(.*\)/$YELLOW\1$NORMAL = \2/g"
}

function env_export() {
    # env_manager() helper
    local file_export=$1

    if [ ! -e ${file_export} ] ; then
	return
    fi

    source ${file_export}
}

function env_edit_file() {
    # env_manager() helper
    local file_value=$1
    local edit=$2

    if [ ! -e ${file_value} -o "$edit" == "0" ] ; then
	return
    fi

    emacs -Q -nw ${file_value} \
	-f sh-mode \
	-f linum-mode \
	--eval '(setq make-backup-files nil)' \
	--eval '(setq linum-format "%2d ")' \
	-f auto-save-mode \
	--eval '(local-set-key (kbd "TAB") (quote forward-word))'
}

function env_make_export() {
    local file_value=$1
    local file_export=$2

    if [ ! -e ${file_value} ] ; then
	return
    fi

    sed -e 's/^ *//g' \
        -e 's/ /\\ /g' \
	-e 's/^\([^\+=]*\)\+=\(.*\)/export \1=${\1}:\2/g' \
	-e 's/^\([^#][^ =]*\)=\(..*\)$/export \1=\2/g' \
	-e 's/^\([^#][^ =]*\)=$/unset \1/g' \
	${file_value} \
	> ${file_export}
}

function env_help() {
    # env_manager() helper
    echo "usage: env [-p|-e] [envfile]"
    echo "        environments setter function for /usr/bin/env"
    echo "        each line of the input file support the following syntax:"
    echo ""
    echo " flags:"
    echo "        -p          print current envfile (default)"
    echo "        -e          edit current envfile"
    echo "        envfile     the filename, see below for \"format\" (.env default)"
    echo ""
    echo " format: (inside envfile)"
    echo "        1. ENV      (query)"
    echo "        2. LHS=VAL  (set)"
    echo "        3. LHS=     (unset)"
    # echo "        4. #        (comment)"
}
